#include <bits/stdc++.h>
using namespace std;

// ==================== NUMBER THEORY ====================



// 1. Primality Check - O(sqrt(n))
bool isPrime(int n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    
    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0)
            return false;
    }
    return true;
}

// 2. Prime Generation (up to n)
vector<int> generatePrimes(int n) {
    vector<int> primes;
    for (int i = 2; i <= n; i++) {
        if (isPrime(i)) {
            primes.push_back(i);
        }
    }
    return primes;
}

// 3. Sieve of Eratosthenes - O(n log log n)
vector<bool> sieveOfEratosthenes(int n) {
    vector<bool> isPrime(n + 1, true);
    isPrime[0] = isPrime[1] = false;
    
    for (int i = 2; i * i <= n; i++) {
        if (isPrime[i]) {
            for (int j = i * i; j <= n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    return isPrime;
}

// Get all primes using sieve
vector<int> getAllPrimes(int n) {
    vector<bool> isPrime = sieveOfEratosthenes(n);
    vector<int> primes;
    for (int i = 2; i <= n; i++) {
        if (isPrime[i]) {
            primes.push_back(i);
        }
    }
    return primes;
}

// 4. Prime Factorization
vector<pair<int, int>> primeFactorization(int n) {
    vector<pair<int, int>> factors;
    
    for (int i = 2; i * i <= n; i++) {
        int count = 0;
        while (n % i == 0) {
            count++;
            n /= i;
        }
        if (count > 0) {
            factors.push_back({i, count});
        }
    }
    
    if (n > 1) {
        factors.push_back({n, 1});
    }
    
    return factors;
}

// 5. Bigmod - (a^b) % m
long long bigmod(long long a, long long b, long long m) {
    long long result = 1;
    a %= m;
    
    while (b > 0) {
        if (b & 1) {
            result = (result * a) % m;
        }
        a = (a * a) % m;
        b >>= 1;
    }
    
    return result;
}

// Count number of divisors
int countDivisors(int n) {
    vector<pair<int, int>> factors = primeFactorization(n);
    int count = 1;
    for (auto p : factors) {
        count *= (p.second + 1);
    }
    return count;
}

// Sum of divisors
long long sumOfDivisors(int n) {
    vector<pair<int, int>> factors = primeFactorization(n);
    long long sum = 1;
    for (auto p : factors) {
        long long temp = (pow(p.first, p.second + 1) - 1) / (p.first - 1);
        sum *= temp;
    }
    return sum;
}

// GCD using Euclidean algorithm
int gcd(int a, int b) {
    while (b) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

// LCM
long long lcm(int a, int b) {
    return (1LL * a * b) / gcd(a, b);
}

// ==================== BINARY SEARCH ====================

// 1. Basic Binary Search - returns index or -1
int binarySearch(vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}

// 2. Lower Bound - first element >= target
int lowerBound(vector<int>& arr, int target) {
    int left = 0, right = arr.size();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    return left;
}

// 3. Upper Bound - first element > target
int upperBound(vector<int>& arr, int target) {
    int left = 0, right = arr.size();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    return left;
}

// Using STL
void stlBinarySearch(vector<int>& arr, int target) {
    // Binary search
    bool found = binary_search(arr.begin(), arr.end(), target);
    
    // Lower bound
    auto lb = lower_bound(arr.begin(), arr.end(), target);
    
    // Upper bound
    auto ub = upper_bound(arr.begin(), arr.end(), target);
    
    // Count occurrences
    int count = ub - lb;
}

// Binary search on answer - Find square root
int sqrtBinarySearch(int n) {
    int left = 0, right = n, ans = 0;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (1LL * mid * mid <= n) {
            ans = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return ans;
}

// Find first occurrence
int firstOccurrence(vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1, result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            result = mid;
            right = mid - 1;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}

// Find last occurrence
int lastOccurrence(vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1, result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            result = mid;
            left = mid + 1;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}

// ==================== SORTING ====================

// 1. Merge Sort
void merge(vector<int>& arr, int left, int mid, int right) {
    vector<int> temp;
    int i = left, j = mid + 1;
    
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp.push_back(arr[i++]);
        } else {
            temp.push_back(arr[j++]);
        }
    }
    
    while (i <= mid) temp.push_back(arr[i++]);
    while (j <= right) temp.push_back(arr[j++]);
    
    for (int i = 0; i < temp.size(); i++) {
        arr[left + i] = temp[i];
    }
}

void mergeSort(vector<int>& arr, int left, int right) {
    if (left >= right) return;
    
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

// 2. Quick Sort
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// 3. STL Sort with custom comparator
bool customCompare(int a, int b) {
    return a > b; // Descending order
}

// For pairs - sort by second element
bool pairCompare(pair<int, int> a, pair<int, int> b) {
    return a.second < b.second;
}

// For strings - sort by length
bool stringCompare(string a, string b) {
    return a.length() < b.length();
}

void stlSortExamples() {
    vector<int> arr = {5, 2, 8, 1, 9};
    
    // Ascending order
    sort(arr.begin(), arr.end());
    
    // Descending order
    sort(arr.begin(), arr.end(), greater<int>());
    
    // Custom comparator
    sort(arr.begin(), arr.end(), customCompare);
    
    // Sort pairs
    vector<pair<int, int>> pairs = {{1, 5}, {2, 3}, {3, 1}};
    sort(pairs.begin(), pairs.end(), pairCompare);
}

// Count inversions using merge sort
long long mergeAndCount(vector<int>& arr, int left, int mid, int right) {
    vector<int> temp;
    int i = left, j = mid + 1;
    long long inv_count = 0;
    
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp.push_back(arr[i++]);
        } else {
            temp.push_back(arr[j++]);
            inv_count += (mid - i + 1);
        }
    }
    
    while (i <= mid) temp.push_back(arr[i++]);
    while (j <= right) temp.push_back(arr[j++]);
    
    for (int i = 0; i < temp.size(); i++) {
        arr[left + i] = temp[i];
    }
    
    return inv_count;
}

long long countInversions(vector<int>& arr, int left, int right) {
    long long inv_count = 0;
    if (left < right) {
        int mid = left + (right - left) / 2;
        inv_count += countInversions(arr, left, mid);
        inv_count += countInversions(arr, mid + 1, right);
        inv_count += mergeAndCount(arr, left, mid, right);
    }
    return inv_count;
}

// ==================== GRAPH ====================

// Adjacency Matrix representation
class GraphMatrix {
    int V;
    vector<vector<int>> adj;
    
public:
    GraphMatrix(int vertices) {
        V = vertices;
        adj.resize(V, vector<int>(V, 0));
    }
    
    void addEdge(int u, int v, int weight = 1) {
        adj[u][v] = weight;
        adj[v][u] = weight; // For undirected graph
    }
    
    void display() {
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                cout << adj[i][j] << " ";
            }
            cout << endl;
        }
    }
};

// Adjacency List representation
class GraphList {
    int V;
    vector<vector<int>> adj;
    
public:
    GraphList(int vertices) {
        V = vertices;
        adj.resize(V);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u); // For undirected graph
    }
    
    // BFS Traversal
    void BFS(int start) {
        vector<bool> visited(V, false);
        queue<int> q;
        
        visited[start] = true;
        q.push(start);
        
        cout << "BFS: ";
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            cout << u << " ";
            
            for (int v : adj[u]) {
                if (!visited[v]) {
                    visited[v] = true;
                    q.push(v);
                }
            }
        }
        cout << endl;
    }
    
    // DFS Traversal (Recursive)
    void DFSUtil(int u, vector<bool>& visited) {
        visited[u] = true;
        cout << u << " ";
        
        for (int v : adj[u]) {
            if (!visited[v]) {
                DFSUtil(v, visited);
            }
        }
    }
    
    void DFS(int start) {
        vector<bool> visited(V, false);
        cout << "DFS: ";
        DFSUtil(start, visited);
        cout << endl;
    }
    
    // DFS Iterative
    void DFSIterative(int start) {
        vector<bool> visited(V, false);
        stack<int> st;
        
        st.push(start);
        
        cout << "DFS Iterative: ";
        while (!st.empty()) {
            int u = st.top();
            st.pop();
            
            if (!visited[u]) {
                visited[u] = true;
                cout << u << " ";
                
                for (int v : adj[u]) {
                    if (!visited[v]) {
                        st.push(v);
                    }
                }
            }
        }
        cout << endl;
    }
    
    // Check if graph is connected
    bool isConnected() {
        vector<bool> visited(V, false);
        
        int start = 0;
        for (int i = 0; i < V; i++) {
            if (adj[i].size() > 0) {
                start = i;
                break;
            }
        }
        
        DFSUtil(start, visited);
        
        for (int i = 0; i < V; i++) {
            if (adj[i].size() > 0 && !visited[i]) {
                return false;
            }
        }
        return true;
    }
    
    // Count connected components
    int countComponents() {
        vector<bool> visited(V, false);
        int count = 0;
        
        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                DFSUtil(i, visited);
                count++;
            }
        }
        
        return count;
    }
    
    // Shortest path in unweighted graph
    void shortestPath(int start, int end) {
        vector<bool> visited(V, false);
        vector<int> parent(V, -1);
        queue<int> q;
        
        visited[start] = true;
        q.push(start);
        
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            
            if (u == end) break;
            
            for (int v : adj[u]) {
                if (!visited[v]) {
                    visited[v] = true;
                    parent[v] = u;
                    q.push(v);
                }
            }
        }
        
        if (parent[end] == -1 && start != end) {
            cout << "No path exists" << endl;
            return;
        }
        
        vector<int> path;
        int current = end;
        while (current != -1) {
            path.push_back(current);
            current = parent[current];
        }
        
        reverse(path.begin(), path.end());
        
        cout << "Shortest path: ";
        for (int node : path) {
            cout << node << " ";
        }
        cout << endl;
    }
    
    // Detect cycle in undirected graph (DFS)
    bool hasCycleUtil(int u, vector<bool>& visited, int parent) {
        visited[u] = true;
        
        for (int v : adj[u]) {
            if (!visited[v]) {
                if (hasCycleUtil(v, visited, u)) {
                    return true;
                }
            } else if (v != parent) {
                return true;
            }
        }
        
        return false;
    }
    
    bool hasCycle() {
        vector<bool> visited(V, false);
        
        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                if (hasCycleUtil(i, visited, -1)) {
                    return true;
                }
            }
        }
        
        return false;
    }
};

// ==================== MAIN FUNCTION ====================

int main() {
    cout << "========== NUMBER THEORY ==========" << endl;
    
    // Primality check
    cout << "Is 17 prime? " << (isPrime(17) ? "Yes" : "No") << endl;
    
    // Sieve
    vector<int> primes = getAllPrimes(50);
    cout << "Primes up to 50: ";
    for (int p : primes) cout << p << " ";
    cout << endl;
    
    // Prime factorization
    cout << "Prime factors of 60: ";
    vector<pair<int, int>> factors = primeFactorization(60);
    for (auto p : factors) {
        cout << p.first << "^" << p.second << " ";
    }
    cout << endl;
    
    // Bigmod
    cout << "2^10 mod 1000 = " << bigmod(2, 10, 1000) << endl;
    
    cout << "\n========== BINARY SEARCH ==========" << endl;
    
    vector<int> arr = {1, 2, 4, 4, 4, 6, 8, 10};
    cout << "Binary search 4: " << binarySearch(arr, 4) << endl;
    cout << "Lower bound 4: " << lowerBound(arr, 4) << endl;
    cout << "Upper bound 4: " << upperBound(arr, 4) << endl;
    
    cout << "\n========== SORTING ==========" << endl;
    
    vector<int> arr2 = {5, 2, 8, 1, 9, 3};
    mergeSort(arr2, 0, arr2.size() - 1);
    cout << "Merge sorted: ";
    for (int x : arr2) cout << x << " ";
    cout << endl;
    
    vector<int> arr3 = {5, 2, 8, 1, 9, 3};
    quickSort(arr3, 0, arr3.size() - 1);
    cout << "Quick sorted: ";
    for (int x : arr3) cout << x << " ";
    cout << endl;
    
    cout << "\n========== GRAPH ==========" << endl;
    
    GraphList g(5);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 3);
    g.addEdge(2, 4);
    
    g.BFS(0);
    g.DFS(0);
    g.shortestPath(0, 4);
    cout << "Has cycle? " << (g.hasCycle() ? "Yes" : "No") << endl;
    
    return 0;
}
